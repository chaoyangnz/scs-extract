// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.
package structs

import (
	"github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
	"bytes"
	"io"
)

type Scs struct {
	Magic []byte
	Version uint16
	Salt uint16
	HashMethod []byte
	EntryCount uint32
	StartOffset uint32
	Padding []byte
	Entries []*Scs_Entry
	_io *kaitai.Stream
	_root *Scs
	_parent interface{}
}
func NewScs() *Scs {
	return &Scs{
	}
}

func (this *Scs) Read(io *kaitai.Stream, parent interface{}, root *Scs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp1 = tmp1
	this.Magic = tmp1
	if !(bytes.Equal(this.Magic, []uint8{83, 67, 83, 35})) {
		return kaitai.NewValidationNotEqualError([]uint8{83, 67, 83, 35}, this.Magic, this._io, "/seq/0")
	}
	tmp2, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Version = uint16(tmp2)
	tmp3, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Salt = uint16(tmp3)
	tmp4, err := this._io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	tmp4 = tmp4
	this.HashMethod = tmp4
	if !(bytes.Equal(this.HashMethod, []uint8{67, 73, 84, 89})) {
		return kaitai.NewValidationNotEqualError([]uint8{67, 73, 84, 89}, this.HashMethod, this._io, "/seq/3")
	}
	tmp5, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.EntryCount = uint32(tmp5)
	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.StartOffset = uint32(tmp6)
	tmp7, err := this._io.ReadBytes(int(12))
	if err != nil {
		return err
	}
	tmp7 = tmp7
	this.Padding = tmp7
	for i := 0; i < int(this.EntryCount); i++ {
		_ = i
		tmp8 := NewScs_Entry()
		err = tmp8.Read(this._io, this, this._root)
		if err != nil {
			return err
		}
		this.Entries = append(this.Entries, tmp8)
	}
	return err
}
type Scs_Entry struct {
	Hash uint64
	Offset uint64
	Flags uint32
	Crc uint32
	Size uint32
	CompressedSize uint32
	_io *kaitai.Stream
	_root *Scs
	_parent *Scs
	_f_isDir bool
	isDir bool
	_f_isVerify bool
	isVerify bool
	_f_dir bool
	dir string
	_f_isCompressed bool
	isCompressed bool
	_f_file bool
	file []byte
	_f_len bool
	len uint32
	_f_isEncrypted bool
	isEncrypted bool
}
func NewScs_Entry() *Scs_Entry {
	return &Scs_Entry{
	}
}

func (this *Scs_Entry) Read(io *kaitai.Stream, parent *Scs, root *Scs) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.Hash = uint64(tmp9)
	tmp10, err := this._io.ReadU8le()
	if err != nil {
		return err
	}
	this.Offset = uint64(tmp10)
	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Flags = uint32(tmp11)
	tmp12, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Crc = uint32(tmp12)
	tmp13, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Size = uint32(tmp13)
	tmp14, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.CompressedSize = uint32(tmp14)
	return err
}
func (this *Scs_Entry) IsDir() (v bool, err error) {
	if (this._f_isDir) {
		return this.isDir, nil
	}
	this.isDir = bool((this.Flags & (1 << 0)) != 0)
	this._f_isDir = true
	return this.isDir, nil
}
func (this *Scs_Entry) IsVerify() (v bool, err error) {
	if (this._f_isVerify) {
		return this.isVerify, nil
	}
	this.isVerify = bool((this.Flags & (1 << 2)) != 0)
	this._f_isVerify = true
	return this.isVerify, nil
}
func (this *Scs_Entry) Dir() (v string, err error) {
	if (this._f_dir) {
		return this.dir, nil
	}
	tmp15, err := this.IsDir()
	if err != nil {
		return "", err
	}
	if (tmp15) {
		thisIo := this._root._io
		_pos, err := thisIo.Pos()
		if err != nil {
			return "", err
		}
		_, err = thisIo.Seek(int64(this.Offset), io.SeekStart)
		if err != nil {
			return "", err
		}
		tmp16, err := this.Len()
		if err != nil {
			return "", err
		}
		tmp17, err := thisIo.ReadBytes(int(tmp16))
		if err != nil {
			return "", err
		}
		tmp17 = tmp17
		this.dir = string(tmp17)
		_, err = thisIo.Seek(_pos, io.SeekStart)
		if err != nil {
			return "", err
		}
		this._f_dir = true
	}
	this._f_dir = true
	return this.dir, nil
}
func (this *Scs_Entry) IsCompressed() (v bool, err error) {
	if (this._f_isCompressed) {
		return this.isCompressed, nil
	}
	this.isCompressed = bool((this.Flags & (1 << 1)) != 0)
	this._f_isCompressed = true
	return this.isCompressed, nil
}
func (this *Scs_Entry) File() (v []byte, err error) {
	if (this._f_file) {
		return this.file, nil
	}
	tmp18, err := this.IsDir()
	if err != nil {
		return nil, err
	}
	if (!(tmp18)) {
		thisIo := this._root._io
		_pos, err := thisIo.Pos()
		if err != nil {
			return nil, err
		}
		_, err = thisIo.Seek(int64(this.Offset), io.SeekStart)
		if err != nil {
			return nil, err
		}
		tmp19, err := this.Len()
		if err != nil {
			return nil, err
		}
		tmp20, err := thisIo.ReadBytes(int(tmp19))
		if err != nil {
			return nil, err
		}
		tmp20 = tmp20
		this.file = tmp20
		_, err = thisIo.Seek(_pos, io.SeekStart)
		if err != nil {
			return nil, err
		}
		this._f_file = true
	}
	this._f_file = true
	return this.file, nil
}
func (this *Scs_Entry) Len() (v uint32, err error) {
	if (this._f_len) {
		return this.len, nil
	}
	var tmp21 uint32;
	tmp22, err := this.IsCompressed()
	if err != nil {
		return 0, err
	}
	if (tmp22) {
		tmp21 = this.CompressedSize
	} else {
		tmp21 = this.Size
	}
	this.len = uint32(tmp21)
	this._f_len = true
	return this.len, nil
}
func (this *Scs_Entry) IsEncrypted() (v bool, err error) {
	if (this._f_isEncrypted) {
		return this.isEncrypted, nil
	}
	this.isEncrypted = bool((this.Flags & (1 << 3)) != 0)
	this._f_isEncrypted = true
	return this.isEncrypted, nil
}
